#!/bin/bash
set -e
export DEBIAN_FRONTEND=noninteractive

userConfPath="/etc/sftp/users.conf"
userConfPathLegacy="/etc/sftp-users.conf"
userConfFinalPath="/var/run/sftp/users.conf"

/etc/init.d/cron start

mkdir -p /etc/sftp

echo " select 'groupadd '||login||'; useradd --gid ' || login || ' '||login||' ;' || 'echo -e '''||password||'\n'||password||''''||' |passwd '||login as comd from sftpaccounts where login is not null and password is not null;" >sql
echo "select 'mkdir -p /home/'||login||'/home/'||login||'; chmod 755  /home/' || login ||';if [  -d \"/sourcehome/'||login||'\" ]; then mount --bind /sourcehome/'|| login || ' /home/'||login||'/home/'||login||'; fi' as comd from sftpaccounts where login is not null and password is not null;">sql2
echo "export PGPASSWORD=$PGPASSWORD" > /dbenv.sh
echo "export PGHOST=$DB_HOST" >> /dbenv.sh
echo "export PGDB=$DB" >> /dbenv.sh
echo "export PGUSER=$PGUSER" >> /dbenv.sh

psql -h proddb.pocnettech.com -A clearinghouse < sql|grep "'">/fixusers.sh
psql -h proddb.pocnettech.com -A clearinghouse < sql2|grep mkdir>>/fixusers.sh

chmod +x /fixusers.sh

cat /fixusers.sh
/fixusers.sh


# echo $SFTP_PASSWORD | sshfs  $SFTP_USER@$SFTP_SERVER:$SFTP_SHARE /home -o nonempty,password_stdin,auto_cache,reconnect,StrictHostKeyChecking=no


function printHelp() {
    echo "Add users as command arguments, STDIN or mounted in $userConfPath"
    echo "Syntax: user:pass[:e][:uid[:gid[:dir1[,dir2]...]]] ..."
    echo "Use --readme for more information and examples."
}

function printReadme() {
    cat /README.md
    echo "TIP: Read this in HTML format here: https://github.com/atmoz/sftp"
}

function createUser() {
    IFS=':' read -a param <<< $@
    user="${param[0]}"
    pass="${param[1]}"

    if [ "${param[2]}" == "e" ]; then
        chpasswdOptions="-e"
        uid="${param[3]}"
        gid="${param[4]}"
        dir="${param[5]}"
    else
        uid="${param[2]}"
        gid="${param[3]}"
        dir="${param[4]}"
    fi

    if [ -z "$user" ]; then
        echo "FATAL: You must at least provide a username."
        exit 1
    fi
    set +e 
    userdel $user

    set -e

    if $(cat /etc/passwd | cut -d: -f1 | grep -q "^$user:"); then
        echo "WARNING: User \"$user\" already exists. Skipping."
        return 0
    fi

    useraddOptions="--no-user-group"

    if [ -n "$uid" ]; then
        useraddOptions="$useraddOptions --non-unique --uid $uid"
    fi

    if [ -n "$gid" ]; then
        if ! $(cat /etc/group | cut -d: -f3 | grep -q "$gid"); then
            groupadd -f --gid $gid "group_$gid"
        fi

        useraddOptions="$useraddOptions --gid $gid"
    fi

    useradd $useraddOptions $user
    mkdir -p /home/$user
    ##chown root:root /home/$user
    #chmod 755 /home/$user

    # Retrieving user id to use it in chown commands instead of the user name
    # to avoid problems on alpine when the user name contains a '.'
    uid=`id $user -u`

    if [ -n "$pass" ]; then
        echo "$user:$pass" | chpasswd $chpasswdOptions
    else
        usermod -p "*" $user # disabled password
    fi

    # Add SSH keys to authorized_keys with valid permissions
    if [ -d /home/$user/.ssh/keys ]; then
     #   cat /home/$user/.ssh/keys/* >> /home/$user/.ssh/authorized_keys
     #   chown $uid /home/$user/.ssh/authorized_keys
     #   chmod 600 /home/$user/.ssh/authorized_keys
     echo "skiping setting permissions"
    fi

    # Make sure dirs exists and has correct permissions
    if [ -n "$dir" ]; then
        IFS=',' read -a dirParam <<< $dir
        for dirPath in ${dirParam[@]}; do
            dirPath=/home/$user/$dirPath
            echo "Creating and/or setting permissions on $dirPath"
            mkdir -p $dirPath
            #chown -R $uid:users $dirPath
        done
    fi
}

if [[ $1 =~ ^--help$|^-h$ ]]; then
    printHelp
    exit 0
fi

if [ "$1" == "--readme" ]; then
    printReadme
    exit 0
fi

# Backward compatibility with legacy config path
if [ ! -f "$userConfPath" -a -f "$userConfPathLegacy" ]; then
    mkdir -p "$(dirname $userConfPath)"
    ln -s "$userConfPathLegacy" "$userConfPath"
fi

# Create users only on first run
if [ ! -f "$userConfFinalPath" ]; then
    mkdir -p "$(dirname $userConfFinalPath)"

    # Append mounted config to final config
    if [ -f "$userConfPath" ]; then
        cat "$userConfPath" | grep -v -e '^$' > "$userConfFinalPath"
    fi

    # Append users from arguments to final config
    for user in "$@"; do
        echo "$user" >> "$userConfFinalPath"
    done

    # Append users from STDIN to final config
    if [ ! -t 0 ]; then
        while IFS= read -r user || [[ -n "$user" ]]; do
            echo "$user" >> "$userConfFinalPath"
        done
    fi

    # Check that we have users in config
    if [ "$(cat "$userConfFinalPath" | wc -l)" == 0 ]; then
        echo "FATAL: No users provided!"
        printHelp
        exit 3
    fi

    # Import users from final conf file
    while IFS= read -r user || [[ -n "$user" ]]; do
        createUser "$user"
    done < "$userConfFinalPath"

    # Generate unique ssh keys for this container, if needed
    if [ ! -f /etc/ssh/ssh_host_ed25519_key ]; then
        ssh-keygen -t ed25519 -f /etc/ssh/ssh_host_ed25519_key -N ''
    fi
    if [ ! -f /etc/ssh/ssh_host_rsa_key ]; then
        ssh-keygen -t rsa -b 4096 -f /etc/ssh/ssh_host_rsa_key -N ''
    fi
fi

if [ ! -z ${HOST_SSH_RSA_KEY+x} ]; then
    echo $HOST_SSH_RSA_KEY | base64 -d > /etc/ssh/ssh_host_rsa_key
    chmod u+rw,o-rwx,g-rwx  /etc/ssh/ssh_host_rsa_key
    echo $HOST_SSH_RSA_KEY_PUB| base64 -d > /etc/ssh/ssh_host_rsa_key.pub    
    chmod u+rw,o-wx,o+r,g-wx,g+r  /etc/ssh/ssh_host_rsa_key.pub
fi
if [ ! -z ${HOST_SSH_ED25519_KEY+x} ]; then
    echo $HOST_SSH_ED25519_KEY| base64 -d > /etc/ssh/ssh_host_ed25519_key
    chmod u+rw,o-rwx,g-rwx /etc/ssh/ssh_host_ed25519_key
    echo $HOST_SSH_ED25519_KEY_PUB| base64 -d> /etc/ssh/ssh_host_ed25519_key.pub      
    chmod u+rw,o-wx,o+r,g-wx,g+r /etc/ssh/ssh_host_ed25519_key.pub
fi



# Source custom scripts, if any
if [ -d /etc/sftp.d ]; then
    for f in /etc/sftp.d/*; do
        if [ -x "$f" ]; then
            echo "Running $f ..."
            $f
        fi
    done
    unset f
fi

if [ ! -z "$EXCLUDE_FROM_LOG_LIST" ]; then

    echo $EXCLUDE_FROM_LOG_LIST| base64 -d > /exclude.txt
    exec /usr/sbin/sshd -D -e |& grep --line-buffered -v -f /exclude.txt

else
    exec /usr/sbin/sshd -D -e
fi
